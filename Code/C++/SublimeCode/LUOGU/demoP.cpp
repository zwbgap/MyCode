#include<iostream>
using namespace std;


//由二维矩阵存储，其索引为油管，存储值为相距距离
class MGraph {
public:
	int vex[8] = { 1,2,3,4,5,6,7,8 };
	double edge[8][8] = {
		    0.0, 1.3, 2.1, 0.9, 0.7, 1.8, 2.0, 1.8,
			1.3, 0.0, 0.9, 1.8, 1.2, 2.8, 2.3, 1.1,
			2.1, 0.9, 0.0, 2.6, 1.7, 2.5, 1.9, 1.0,
			0.9, 1.8, 2.6, 0.0, 0.7, 1.6, 1.5, 0.9,
			0.7, 1.2, 1.7, 0.7, 0.0, 0.9, 1.1, 0.8,
			1.8, 2.8, 2.5, 1.6, 0.9, 0.0, 0.6, 1.0,
			2.0, 2.3, 1.9, 1.5, 1.1, 0.6, 0.0, 0.5,
			1.8, 1.1, 1.0, 0.9, 0.8, 1.0, 0.5, 0.0
	};
	static const int vexnum = 8;
};
void Prim(MGraph g, int v0, int& sum);


/*
v0是初始化的起始点，即从0开始
v是已标记点的下一个最短距离的顶点
sum是记录所有走过的路径权值之和
lowcost是记录从当前所有已加入的点中，到未加入的点中的最短距离
min是记录一个临时比较的值。它用来辅助更新出最小的最短距离
vset是顶点集，标为0代表还没有被算过（走过），标为1代表已经被算过（走过）了。
*/

void Prim(MGraph g, int v0, double& sum) {
	bool vset[8];
	int v;
	double lowcost[8], min;
	int i, j, k, m;
	v = v0, m = v0;
	cout << "起始点：" << g.vex[v0] << endl <<"下面按顺序依次通过："  << endl;
	//现在把最小权值记录为从初始点出发的边的权值，并把所有点标记为0，代表还没算过
	for (i = 0; i < g.vexnum; ++i) {
		lowcost[i] = g.edge[v0][i];
		vset[i] = 0;
	}
	vset[v0] = 1;//初始点标为1，表示算过了
	sum = 5;
	for (i = 0; i < g.vexnum - 1; ++i) {
		min = 1000;
		//下面从当前生成树到其余顶点最短边中权值最小的一条
		for (j = 0; j < g.vexnum; ++j) {
			if (!vset[j] && lowcost[j] < min) {
				min = lowcost[j];
				k = j;
			}
		}
		vset[k] = 1;//找到后记为1
		v = k;
		cout << g.vex[m] << " 到达点 " << g.vex[v] << "  当前路径权值为：" << min << endl;
		m = v;
		sum += min;
		//下面是 以刚加入的顶点v为中介点，更新所有最短边的权值
		for (j = 0; j < g.vexnum; ++j) {
			if (!vset[j] && g.edge[v][j] < lowcost[j]) {
				lowcost[j] = g.edge[v][j];
			}
		}	
	}
	cout << "所有路径总和为：" << sum << "（海岸到1号距离为:5km）" << endl;
}

int main(void) {
	MGraph g;
	/*g.edge = {
		0.0,	1.3,	2.1,	0.9,	0.7,	1.8,	2.0,	1.8,
		1.3,	0.0,	0.9,	1.8,	1.2,	2.8,	2.3,	1.1,
		2.1,	0.9,	0.0,	2.6,	1.7,	2.5,	1.9,	1.0,
		0.9,	1.8,	2.6,	0.0,	0.7,	1.6,	1.5,	0.9,
		0.7,	1.2,	1.7,	0.7,	0.0,	0.9,	1.1,	0.8,
		1.8,	2.8,	2.5,	1.6,	0.9,	0.0,	0.6,	1.0,
		2.0,	2.3,	1.9,	1.5,	1.1,	0.6,	0.0,	0.5,
		1.8,	1.1,	1.0,	0.9,	0.8,	1.0,	0.5,	0.0
	};
	g.vex = { 1,2,3,4,5,6,7,8 };*/
	double sum = 0; 
	int v0 = 0;
	Prim(g,v0,sum);
	
	return 0;
}

